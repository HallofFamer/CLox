namespace test.std;
//using clox.std.util.Promise;
using clox.std.util.Timer;


class Promise { 
    __init__(executor){ 
        this.handlers = [];
        this.onCatch = nil;
        this.onFinally = nil;
        this.state = "pending";
        this.value = nil;
        this.error = nil;
        executor(this.fulfill, this.reject);
    }

    then(closure) { 
        if (this.state == "fulfilled") this.value = closure(this.value);
        else this.handlers.add(closure);
        return this;
    }

    `catch`(closure) { 
        if (this.state == "rejected") closure(this.error);
        else this.onCatch = closure;
        return this;
    }

    fulfill(value) { 
        this.value = value;
        this.state = "fulfilled";
        var index = 0;
        var handler;
        while (index < this.handlers.length) { 
            handler = this.handlers[index];
            this.value = handler(this.value);
        }
    }

    reject(value) { 
        this.error = value;
        this.status = "rejected";
        if (this.onCatch) this.onCatch(this.error);
    }

    class resolve(value) { 
        if (value.instanceOf(Promise)) return value;
        else {
            return Promise(fun(resolve, reject){
                resolve(value);
            });
        }
    }

    class all(promises) { 
        var results = [];
        var completedPromises = 0;

        return Promise(fun(fulfill, reject){ 
            promises.eachIndex(fun(index, promise){ 
                var onThen = fun(result) { 
                    results[index] = result;
                    completedPromises = completedPromises + 1;
                    if (completedPromises == promises.length) fulfill(results);
                };
                var onCatch = fun(error) { reject(error); };
                
                promise.then(onThen);
            });
        });
    }

    class any(promises) { 
        var errors = [];
        var rejectedPromises = 0;

        return Promise(fun(fulfill, reject){ 
            promises.eachIndex(fun(index, promise){ 
                var onCatch = fun(error) { 
                    errors[index] = error;
                    rejectedPromises = rejectedPromises + 1;
                    if (rejectedPromises == promises.length) reject(results);
                };
                Promise.resolve(promise).then(fulfill).catch(onCatch);
            });
        });
    }
}

/*
val p1 = Promise(fun(resolve, reject) { 
    Timer.timeout(fun(){ 
        resolve(1); 
    }, 500);
});
val p2 = Promise(fun(resolve, reject) { 
    Timer.timeout(fun(){ 
        resolve(2); 
    }, 1000);
});
val p3 = Promise(fun(resolve, reject) { 
    Timer.timeout(fun(){ 
        resolve(3); 
    }, 300);
});

Promise.all([p1, p2, p3]).then(fun(result) { println(result); });
*/

val promise = Promise({|fulfill, reject|
    Timer.timeout({ fulfill("hello world"); }, 1000);
});

println("Promise created: ${promise}");
var result = promise.then({|value| println("Promise resolved: ${value}") })
                    .catch({|exception| println("promise failed: ${exception.message}") });