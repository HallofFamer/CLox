trait TEnumerable { 

    next(index) { 
        error("Not implemented, subclass responsibility.");
    }

    nextValue(index) { 
        error("Not implemented, subclass responsibility.");
    }
}

class Collection with TEnumerable {
    
    init(){
        error("Cannot instantiate from class Collection.");
    }

    add(element) {
        error("Not implemented, subclass responsibility.");
    }

    addAll(collection){ 
        for(var element : collection){ 
            this.add(element);
        }
    }

    collect(closure) {
        var collected = this.getClass()();
        for(var element : this){
            collected.add(closure(element));
        }
        return collected;
    }

    detect(closure) { 
        for(var element : this){
            if(closure(element)) return element;
        }
        return nil;
    }

    each(closure) {
        for(var element : this){ 
            closure(element);
        }
    }

    isEmpty(){
        var i = 0;
        for(var element : this){
            i = i + 1;
        }
        return (i == 0);
    }

    length(){
        var i = 0;
        for(var element : this){
            i = i + 1;
        }
        return i;
    }

    reject(closure) {
        var selected = this.getClass()();
        for(var element : this){ 
            if(!closure(element)) selected.add(element);
        }
        return selected;
    }

    select(closure) { 
        var selected = this.getClass()();
        for(var element : this){ 
            if(closure(element)) selected.add(element);
        }
        return selected;
    }

    toArray(){ 
        var array = [];
        for(var element : this){
            array.add(element);
        }
        return array;
    }
}

class Dictionary < Collection {
    collect(closure){
        var collected = this.getClass()();
        for(var (key, value) : this){ 
            collected[key] = closure(key, value);
        }
        return collected;
    }

    detect(closure){ 
        for(var (key, value) : this){ 
            if(closure(key, value)) return value;
        }
        return nil;
    }

    each(closure){
        for(var (key, value) : this){ 
            closure(key, value);
        }
    }

    eachKey(closure){ 
        for(var (key, value) : this){ 
            closure(key);
        } 
    }

    eachValue(closure){
        for(var (key, value) : this){ 
            closure(value);
        } 
    }

    reject(closure){
        var selected = this.getClass()();
        for(var (key, value) : this){ 
            if(!closure(key, value)) selected[key] = value;
        }
    }

    select(closure){ 
        var selected = this.getClass()();
        for(var (key, value) : this){ 
            if(closure(key, value)){
                 selected[key] = value;
            }
        }
        return selected;
    }
}